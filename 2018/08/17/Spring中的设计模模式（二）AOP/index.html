<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="AOP(Aspect Oriented Programming)意为：面向切面编程，是通过预编译方式和运行期间动态代理实现程序的统一维护的一种技术。
AOP是OOP的延续，是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分直接的耦合度降低，提高程"/>
    

    <!--Author-->
    
        <meta name="author" content="wulin"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Spring中的设计模模式（二）AOP"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="AOP(Aspect Oriented Programming)意为：面向切面编程，是通过预编译方式和运行期间动态代理实现程序的统一维护的一种技术。
AOP是OOP的延续，是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分直接的耦合度降低，提高程"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="wulin&#39;s"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://yoursite.com/img/home-bg.jpg"/>
    

    <!-- Title -->
    
    <title>Spring中的设计模模式（二）AOP - wulin&#39;s</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/wulinbaba/wulinbaba.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Spring中的设计模模式（二）AOP</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-08-17
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://img31.mtime.cn/pi/2015/03/03/161036.48387324_1000X1000.jpg" alt=""></h2><p>AOP(Aspect Oriented Programming)意为：面向切面编程，是通过预编译方式和运行期间动态代理实现程序的统一维护的一种技术。</p>
<p>AOP是OOP的延续，是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分直接的耦合度降低，提高程序的可重用性，同时提高了开发效率。</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/1.png)</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/2.png)</p>
<p>而<strong>动态代理</strong>是实现Spring AOP的基础，这就涉及到了<strong>代理模式</strong>。</p>
<p>​          </p>
<h2 id="一、为什么需要代理模式"><a href="#一、为什么需要代理模式" class="headerlink" title="一、为什么需要代理模式"></a>一、为什么需要代理模式</h2><h3 id="1、代理模式"><a href="#1、代理模式" class="headerlink" title="1、代理模式"></a>1、代理模式</h3><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>​       </p>
<h3 id="2、介绍"><a href="#2、介绍" class="headerlink" title="2、介绍"></a>2、介绍</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 </p>
<p>​              </p>
<h3 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h3><p>假设需实现一个计算的类Math、完成加、减、乘、除功能，如下所示： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Math &#123;</span><br><span class="line">    //加</span><br><span class="line">    public int add(int n1,int n2)&#123;</span><br><span class="line">        int result=n1+n2;</span><br><span class="line">        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //减</span><br><span class="line">    public int sub(int n1,int n2)&#123;</span><br><span class="line">        int result=n1-n2;</span><br><span class="line">        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //乘</span><br><span class="line">    public int mut(int n1,int n2)&#123;</span><br><span class="line">        int result=n1*n2;</span><br><span class="line">        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //除</span><br><span class="line">    public int div(int n1,int n2)&#123;</span><br><span class="line">        int result=n1/n2;</span><br><span class="line">        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在需求发生了变化，要求项目中所以的类在执行方法时输出执行耗时。最直接的办法是修改源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Math &#123;</span><br><span class="line">    //加</span><br><span class="line">    public int add(int n1,int n2)&#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=n1+n2;</span><br><span class="line">        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //减</span><br><span class="line">    public int sub(int n1,int n2)&#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=n1-n2;</span><br><span class="line">        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //乘</span><br><span class="line">    public int mut(int n1,int n2)&#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=n1*n2;</span><br><span class="line">        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //除</span><br><span class="line">    public int div(int n1,int n2)&#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=n1/n2;</span><br><span class="line">        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //模拟延时</span><br><span class="line">    public void lazy()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n=(int)new Random().nextInt(500);</span><br><span class="line">            Thread.sleep(n);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试运行： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        Math math=new Math();</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/3.png)</p>
<p>缺点：</p>
<p>1、工作量特别大，如果项目中有多个类，多个方法，则要修改多次。</p>
<p>2、违背了设计原则：开闭原则（OCP），对扩展开放，对修改关闭，而为了增加功能把每个方法都修改了，也不便于维护。</p>
<p>3、违背了设计原则：单一职责（SRP），每个方法除了要完成自己本身的功能，还要计算耗时、延时；每一个方法引起它变化的原因就有多种。</p>
<p>4、违背了设计原则：依赖倒转（DIP），抽象不应该依赖细节，两者都应该依赖抽象。而在Test类中，Test与Math都是细节。</p>
<p>使用静态代理可以解决部分问题。</p>
<p>​                 </p>
<h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p> 1、定义抽象主题接口。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接口</span><br><span class="line"> * 抽象主题</span><br><span class="line"> */</span><br><span class="line">public interface IMath &#123;</span><br><span class="line">    //加</span><br><span class="line">    int add(int n1, int n2);</span><br><span class="line"></span><br><span class="line">    //减</span><br><span class="line">    int sub(int n1, int n2);</span><br><span class="line"></span><br><span class="line">    //乘</span><br><span class="line">    int mut(int n1, int n2);</span><br><span class="line"></span><br><span class="line">    //除</span><br><span class="line">    int div(int n1, int n2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、主题类，算术类，实现抽象接口。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被代理的目标对象</span><br><span class="line"> *真实主题</span><br><span class="line"> */</span><br><span class="line">public class Math implements IMath &#123;</span><br><span class="line">    //加</span><br><span class="line">    public int add(int n1,int n2)&#123;</span><br><span class="line">        int result=n1+n2;</span><br><span class="line">        System.out.println(n1+&quot;+&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //减</span><br><span class="line">    public int sub(int n1,int n2)&#123;</span><br><span class="line">        int result=n1-n2;</span><br><span class="line">        System.out.println(n1+&quot;-&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //乘</span><br><span class="line">    public int mut(int n1,int n2)&#123;</span><br><span class="line">        int result=n1*n2;</span><br><span class="line">        System.out.println(n1+&quot;X&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //除</span><br><span class="line">    public int div(int n1,int n2)&#123;</span><br><span class="line">        int result=n1/n2;</span><br><span class="line">        System.out.println(n1+&quot;/&quot;+n2+&quot;=&quot;+result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、代理类 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 静态代理类</span><br><span class="line"> */</span><br><span class="line">public class MathProxy implements IMath &#123;</span><br><span class="line"></span><br><span class="line">    //被代理的对象</span><br><span class="line">    IMath math=new Math();</span><br><span class="line">    </span><br><span class="line">    //加</span><br><span class="line">    public int add(int n1, int n2) &#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=math.add(n1, n2);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //减法</span><br><span class="line">    public int sub(int n1, int n2) &#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=math.sub(n1, n2);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //乘</span><br><span class="line">    public int mut(int n1, int n2) &#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=math.mut(n1, n2);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //除</span><br><span class="line">    public int div(int n1, int n2) &#123;</span><br><span class="line">        //开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        int result=math.div(n1, n2);</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟延时</span><br><span class="line">    public void lazy()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n=(int)new Random().nextInt(500);</span><br><span class="line">            Thread.sleep(n);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、测试运行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    IMath math=new MathProxy();</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/4.png)</p>
<p>通过静态代理，对于上述的4个问题：</p>
<p>已解决：</p>
<p>1、解决了“开闭原则（OCP）”的问题，因为并没有修改Math类，而扩展出了MathProxy类。</p>
<p>2、解决了“依赖倒转（DIP）”的问题，通过引入接口。</p>
<p>3、解决了“单一职责（SRP）”的问题，Math类不再需要去计算耗时与延时操作，但从某些方面讲MathProxy还是存在该问题。</p>
<p>未解决：</p>
<p>4、如果项目中有多个类，则需要编写多个代理类，工作量大，不好修改，不好维护，不能应对变化。</p>
<p>如果要解决上面的问题，可以使用动态代理。</p>
<p>​      </p>
<h2 id="三、动态代理，使用JDK内置的Proxy实现"><a href="#三、动态代理，使用JDK内置的Proxy实现" class="headerlink" title="三、动态代理，使用JDK内置的Proxy实现"></a>三、动态代理，使用JDK内置的Proxy实现</h2><p>只需要一个代理类，而不是针对每个类编写代理类。在上一个示例中修改代理类MathProxy如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理类</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    //被代理的对象</span><br><span class="line">    Object targetObject;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获得被代理后的对象</span><br><span class="line">     * @param object 被代理的对象</span><br><span class="line">     * @return 代理后的对象</span><br><span class="line">     */</span><br><span class="line">    public Object getProxyObject(Object object)&#123;</span><br><span class="line">        this.targetObject=object;</span><br><span class="line">        return Proxy.newProxyInstance(</span><br><span class="line">                targetObject.getClass().getClassLoader(), //类加载器</span><br><span class="line">                targetObject.getClass().getInterfaces(),  //获得被代理对象的所有接口</span><br><span class="line">                this);                                    //InvocationHandler对象</span><br><span class="line">//loader:一个ClassLoader对象，定义了由哪个ClassLoader对象来生成代理对象进行加载</span><br><span class="line">//interfaces:一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</span><br><span class="line">//this:一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上，间接通过invoke来执行</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当用户调用对象中的每个方法时都通过下面的方法执行，方法必须在接口</span><br><span class="line">     * proxy 被代理后的对象</span><br><span class="line">     * method 将要被执行的方法信息（反射）</span><br><span class="line">     * args 执行方法时需要的参数</span><br><span class="line">     */</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        //被织入的内容，开始时间</span><br><span class="line">        long start=System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        </span><br><span class="line">        //使用反射在目标对象上调用方法并传入参数</span><br><span class="line">        Object result=method.invoke(targetObject, args);</span><br><span class="line">        </span><br><span class="line">        //被织入的内容，结束时间</span><br><span class="line">        Long span= System.currentTimeMillis()-start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot;+span);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //模拟延时</span><br><span class="line">    public void lazy()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n=(int)new Random().nextInt(500);</span><br><span class="line">            Thread.sleep(n);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    //实例化一个MathProxy代理对象</span><br><span class="line">    //通过getProxyObject方法获得被代理后的对象</span><br><span class="line">    IMath math=(IMath)new DynamicProxy().getProxyObject(new Math());</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    IMessage message=(IMessage) new DynamicProxy().getProxyObject(new Message());</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test02()</span><br><span class="line">    &#123;</span><br><span class="line">        message.message();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> JDK内置的Proxy动态代理可以在运行时动态生成字节码，而没必要针对每个类编写代理类。中间主要使用到了一个接口<strong>InvocationHandler</strong>与<strong>Proxy.newProxyInstance</strong>静态方法。</p>
<p>使用内置的Proxy实现动态代理有一个问题：被代理的类必须实现接口，未实现接口则没办法完成动态代理。</p>
<p>如果项目中有些类没有实现接口，则不应该为了实现动态代理而刻意去抽出一些没有实例意义的接口，通过cglib可以解决该问题。</p>
<p>​        </p>
<h2 id="四、动态代理，使用CGLIB实现"><a href="#四、动态代理，使用CGLIB实现" class="headerlink" title="四、动态代理，使用CGLIB实现"></a>四、动态代理，使用CGLIB实现</h2><p>CGLIB(Code Generation Library)是一个开源项目,是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口，通俗说CGLIB可以在运行时动态生成字节码。 </p>
<p>1、通过maven引用CGLIB，修改pom.xml，添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、使用CGLIB完成动态代理，大概的原理是：CGLIB继承被代理的类，重写方法，织入通知，动态生成字节码并运行，因为是继承所以final类没办法动态代理。具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 动态代理类</span><br><span class="line"> * 实现了一个方法拦截器接口</span><br><span class="line"> */</span><br><span class="line">public class DynamicProxy implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    // 被代理对象</span><br><span class="line">    Object targetObject;</span><br><span class="line"></span><br><span class="line">    //动态生成一个新的类，使用父类的无参构造方法创建一个指定了特定回调的代理实例</span><br><span class="line">    public Object getProxyObject(Object object) &#123;</span><br><span class="line">        this.targetObject = object;</span><br><span class="line">        //增强器，动态代码生成器</span><br><span class="line">        Enhancer enhancer=new Enhancer();</span><br><span class="line">        //回调方法</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        //设置生成类的父类类型</span><br><span class="line">        enhancer.setSuperclass(targetObject.getClass());</span><br><span class="line">        //动态生成字节码并返回代理对象</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 拦截方法</span><br><span class="line">    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        // 被织入的横切内容，开始时间 before</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line"></span><br><span class="line">        // 调用方法</span><br><span class="line">        Object result = methodProxy.invoke(targetObject, args);</span><br><span class="line"></span><br><span class="line">        // 被织入的横切内容，结束时间</span><br><span class="line">        Long span = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot; + span);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟延时</span><br><span class="line">    public void lazy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n = (int) new Random().nextInt(500);</span><br><span class="line">            Thread.sleep(n);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、测试运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    //实例化一个DynamicProxy代理对象</span><br><span class="line">    //通过getProxyObject方法获得被代理后的对象</span><br><span class="line">    Math math=(Math)new DynamicProxy().getProxyObject(new Math());</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">    //另一个被代理的对象,不再需要重新编辑代理代码</span><br><span class="line">    Message message=(Message) new DynamicProxy().getProxyObject(new Message());</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test02()</span><br><span class="line">    &#123;</span><br><span class="line">        message.message();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用CGLIB可以实现动态代理，即使被代理的类可以没有实现接口，被代理的类也必须不是final类。 </p>
<p>​            </p>
<h2 id="五、使用Spring实现AOP"><a href="#五、使用Spring实现AOP" class="headerlink" title="五、使用Spring实现AOP"></a>五、使用Spring实现AOP</h2><p>横切关注点：跨越应用程序多个模块的方法或功能。即，与业务逻辑无关的，但是需要关注的部分，就是横切关注点。比如开头图片中的”验证参数”、”系统日志“、”安全检查“、”事务管理“等。</p>
<p>切面（ASPECT）：横切关注点被模块化的特殊对象。它是一个类。</p>
<p>通知（Advice）：切面必须要完成的工作。它是类中的一个方法。</p>
<p>目标（Target）：被通知的对象。</p>
<p>代理（Proxy）：向目标对象应用通知后创建的对象。</p>
<p>切入点（PointCut）：切面通知执行的“地点”的定义。</p>
<p>连接点（JointPoint）：与切入点匹配的执行点。</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/5.png)</p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: </p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/6.png)</p>
<p>1、新建 一个Maven项目，修改pom.xml文件，在项目中引入Spring核心库与AOP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.3.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、定义通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.MethodBeforeAdvice;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 前置通知</span><br><span class="line"> */</span><br><span class="line">public class BeforeAdvice implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * method 方法信息</span><br><span class="line">     * args 参数</span><br><span class="line">     * target 被代理的目标对象</span><br><span class="line">     */</span><br><span class="line">    public void before(Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;-----------------前置通知-----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import org.springframework.aop.AfterReturningAdvice;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 后置通知</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AfterAdvice implements AfterReturningAdvice &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * returnValue 返回值</span><br><span class="line">     * method 被调用的方法</span><br><span class="line">     * args 方法参数</span><br><span class="line">     * target 被代理对象</span><br><span class="line">     */</span><br><span class="line">    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;-----------------后置通知-----------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 环绕通知</span><br><span class="line"> * 方法拦截器</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SurroundAdvice implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation i) throws Throwable &#123;</span><br><span class="line">        //前置横切逻辑</span><br><span class="line">        System.out.println(&quot;方法&quot; + i.getMethod() + &quot; 被调用在对象&quot; + i.getThis() + &quot;上，参数 &quot; + i.getArguments());</span><br><span class="line">        //方法调用</span><br><span class="line">        Object ret = i.proceed();</span><br><span class="line">        //后置横切逻辑</span><br><span class="line">        System.out.println(&quot;返回值：&quot;+ ret);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、创建代理工厂，设置被代理对象，添加通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.aop.framework.ProxyFactory;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        //实例化Spring代理工厂</span><br><span class="line">        ProxyFactory factory=new ProxyFactory();</span><br><span class="line">        //设置被代理的对象</span><br><span class="line">        factory.setTarget(new Math());</span><br><span class="line">        //添加通知，横切逻辑</span><br><span class="line">        factory.addAdvice(new BeforeAdvice());</span><br><span class="line">        factory.addAdvice(new AfterAdvice());</span><br><span class="line">        factory.addAdvice(new SurroundAdvice());</span><br><span class="line">        //从代理工厂中获得代理对象</span><br><span class="line">        IMath math=(IMath) factory.getProxy();</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test02()</span><br><span class="line">    &#123;</span><br><span class="line">        //message.message();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/7.png)</p>
<p>​                          </p>
<p>在上面的示例中如果要代理不同的对象需要反复创建ProxyFactory对象，代码会冗余。同样以实现方法耗时为示例代码如下： </p>
<p>1、创建一个环绕通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于完成计算方法执行时长的环绕通知</span><br><span class="line"> */</span><br><span class="line">public class TimeSpanAdvice implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        // 被织入的横切内容，开始时间 before</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        lazy();</span><br><span class="line">        </span><br><span class="line">        //方法调用</span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        </span><br><span class="line">        // 被织入的横切内容，结束时间</span><br><span class="line">        Long span = System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(&quot;共用时：&quot; + span);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟延时</span><br><span class="line">    public void lazy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n = (int) new Random().nextInt(500);</span><br><span class="line">            Thread.sleep(n);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、封装动态代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.aop.framework.ProxyFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public abstract class DynamicProxy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获得代理对象</span><br><span class="line">     * @param object 被代理的对象</span><br><span class="line">     * @return 代理对象</span><br><span class="line">     */</span><br><span class="line">    public static Object getProxy(Object object)&#123;</span><br><span class="line">        //实例化Spring代理工厂</span><br><span class="line">        ProxyFactory factory=new ProxyFactory();</span><br><span class="line">        //设置被代理的对象</span><br><span class="line">        factory.setTarget(object);</span><br><span class="line">        //添加通知，横切逻辑</span><br><span class="line">        factory.addAdvice(new TimeSpanAdvice());</span><br><span class="line">        return factory.getProxy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、测试运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.aop.framework.ProxyFactory;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        //从代理工厂中获得代理对象</span><br><span class="line">        IMath math=(IMath) DynamicProxy.getProxy(new Math());</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test02()</span><br><span class="line">    &#123;</span><br><span class="line">        IMessage message=(IMessage) DynamicProxy.getProxy(new Message());</span><br><span class="line">        message.message();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2018/08/17/Spring中的设计模模式（二）AOP/Spring中的设计模模式(二" alt="">AOP/8.png)</p>
<p>​               </p>
<h2 id="六、使用IOC配置的方式实现AOP"><a href="#六、使用IOC配置的方式实现AOP" class="headerlink" title="六、使用IOC配置的方式实现AOP"></a>六、使用IOC配置的方式实现AOP</h2><p>1、修改pom.xml，添加依赖，引入Spring IOC的核心jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、创建IOC的配置文件beans.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 被代理的目标对象 --&gt;</span><br><span class="line">    &lt;bean id=&quot;target&quot; class=&quot;com.wulin.aoptest.Math&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--通知、横切逻辑--&gt;</span><br><span class="line">    &lt;bean id=&quot;advice&quot; class=&quot;com.wulin.aoptest.AfterAdvice&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!--代理对象 --&gt;</span><br><span class="line">    &lt;!--interceptorNames 通知数组 --&gt;</span><br><span class="line">    &lt;!--p:target-ref 被代理的对象--&gt;</span><br><span class="line">    &lt;!--p:proxyTargetClass 被代理对象是否为一个类，如果是则使用cglib,否则使用jdk动态代理  --&gt;</span><br><span class="line">    &lt;bean id=&quot;proxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">        p:interceptorNames=&quot;advice&quot;</span><br><span class="line">        p:target-ref=&quot;target&quot;</span><br><span class="line">        p:proxyTargetClass=&quot;true&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>3、获得代理类的实例并测试运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        //容器</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br><span class="line">        //从代理工厂中获得代理对象</span><br><span class="line">        IMath math=(IMath)ctx.getBean(&quot;proxy&quot;);</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个值得注意的问题：从容器中获得proxy对象时应该是</p>
<p>org.springframework.aop.framework.ProxyFactoryBean类型的对象(如下代码所示)，但这里直接就转换成IMath类型了。</p>
<p>这是因为：ProxyFactoryBean本质上是一个用来生产Proxy的FactoryBean，如果容器中的某个对象持有某个FactoryBean的引用，它取得的不是FactoryBean本身而是 FactoryBean的getObject()方法所返回的对象。</p>
<p>所以如果容器中某个对象依赖于ProxyFactoryBean那么它将会使用到 ProxyFactoryBean的getObject()方法所返回的代理对象这就是ProxyFactryBean得以在容器中使用的原因。 </p>
<p>​          </p>
<h2 id="七、使用XML配置Spring-AOP切面"><a href="#七、使用XML配置Spring-AOP切面" class="headerlink" title="七、使用XML配置Spring AOP切面"></a>七、使用XML配置Spring AOP切面</h2><p>1、修改pom.xml，添加依赖，引入AspectJ 的jar包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.6.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.6.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2、定义通知</p>
<p>该通知不再需要实现任何接口或继承抽象类，一个普通的bean即可，方法可以带一个JoinPoint连接点参数，用于获得连接点信息，如方法名，参数，代理对象等。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通知</span><br><span class="line"> */</span><br><span class="line">public class Advices &#123;</span><br><span class="line">    //前置通知</span><br><span class="line">    public void before(JoinPoint jp)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;--------------------bofore--------------------&quot;);</span><br><span class="line">        System.out.println(&quot;方法名：&quot;+jp.getSignature()+&quot;，参数：&quot;+jp.getArgs().length+&quot;，代理对象：&quot;+jp.getTarget());</span><br><span class="line">    &#125;</span><br><span class="line">    //后置通知</span><br><span class="line">    public void after(JoinPoint jp)&#123;</span><br><span class="line">        System.out.println(&quot;--------------------after--------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通知的类型有多种，有些参数会不一样，特别是环绕通知，通知类型如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//前置通知</span><br><span class="line">public void beforeMethod(JoinPoint joinPoint)</span><br><span class="line"></span><br><span class="line">//后置通知</span><br><span class="line">public void afterMethod(JoinPoint joinPoint)</span><br><span class="line"></span><br><span class="line">//返回值通知</span><br><span class="line">public void afterReturning(JoinPoint joinPoint, Object result)</span><br><span class="line"></span><br><span class="line">//抛出异常通知</span><br><span class="line">//在方法出现异常时会执行的代码可以访问到异常对象，可以指定在出现特定异常时在执行通知代码</span><br><span class="line">public void afterThrowing(JoinPoint joinPoint, Exception ex)</span><br><span class="line"></span><br><span class="line">//环绕通知</span><br><span class="line">//环绕通知需要携带ProceedingJoinPoint类型的参数</span><br><span class="line">//环绕通知类似于动态代理的全过程：ProceedingJoinPoint类型的参数可以决定是否执行目标方法。</span><br><span class="line">//而且环绕通知必须有返回值，返回值即为目标方法的返回值</span><br><span class="line">public Object aroundMethod(ProceedingJoinPoint pjd)</span><br></pre></td></tr></table></figure>
<p>3、配置IOC容器依赖的xml文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;!--被代理的目标对象 --&gt;</span><br><span class="line">    &lt;bean id=&quot;math&quot; class=&quot;com.wulin.aoptest.Math&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 通知 --&gt;</span><br><span class="line">    &lt;bean id=&quot;advice&quot; class=&quot;com.wulin.aoptest.Advices&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- AOP配置 --&gt;</span><br><span class="line">    &lt;!-- proxy-target-class属性表示被代理的类是否为一个没有实现接口的类，Spring会依据实现了接口则使用JDK内置的动态代理，如果未实现接口则使用cblib --&gt;</span><br><span class="line">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">        &lt;!-- 切面配置 --&gt;</span><br><span class="line">        &lt;!--ref表示通知对象的引用 --&gt;</span><br><span class="line">        &lt;aop:aspect ref=&quot;advice&quot;&gt;</span><br><span class="line">            &lt;!-- 配置切入点(横切逻辑将注入的精确位置) --&gt;</span><br><span class="line">            &lt;aop:pointcut expression=&quot;execution(* com.wulin.aoptest.Math.*(..))&quot; id=&quot;pointcut1&quot;/&gt;</span><br><span class="line">            &lt;!--声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中 --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;</span><br><span class="line">            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>aop:aspect表示切面配置， ref表示通知对象的引用；aop:pointcut是配置切入点，就是横切逻辑将注入的精确位置，那些包，类，方法需要拦截注入横切逻辑。</p>
<p>aop:before用于声明通知，method指定通知类型，pointcut指定切点，就是该通知应该注入那些方法中。在aop Schema中，每种通知类型都对应一个特定地XML元素。通知元素需要pointcut-ref属性来引用切入点，或者用pointcut属性直接嵌入切入点表达式。method属性指定切面类中通知方法的名称。有如下几种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 前置通知 --&gt;</span><br><span class="line">&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;</span><br><span class="line">&lt;!-- 后置通知 --&gt;</span><br><span class="line">&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut1&quot;/&gt;</span><br><span class="line">&lt;!--环绕通知 --&gt;</span><br><span class="line">&lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.wulin.aoptest.Math.s*(..))&quot;/&gt;</span><br><span class="line">&lt;!--异常通知 --&gt;</span><br><span class="line">&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* com.wulin.aoptest.Math.d*(..))&quot;  throwing=&quot;exp&quot;/&gt;</span><br><span class="line">&lt;!-- 返回值通知 --&gt;</span><br><span class="line">&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut=&quot;execution(* com.wulin.aoptest.Math.m*(..))&quot; returning=&quot;result&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>4、获得代理对象，测试运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.aop.framework.ProxyFactoryBean;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    @org.junit.Test</span><br><span class="line">    public void test01()</span><br><span class="line">    &#123;</span><br><span class="line">        //容器</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beansOfAOP.xml&quot;);</span><br><span class="line">        //从代理工厂中获得代理对象</span><br><span class="line">        IMath math=(IMath)ctx.getBean(&quot;math&quot;);</span><br><span class="line">        int n1=100,n2=5;</span><br><span class="line">        math.add(n1, n2);</span><br><span class="line">        math.sub(n1, n2);</span><br><span class="line">        math.mut(n1, n2);</span><br><span class="line">        math.div(n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>Spring AOP的作用在于，它可以将与业务逻辑无关的，但是需要关注的部分，就是横切关注点，比如开头图片中的”验证参数”、”系统日志“、”安全检查“、”事务管理“等，从业务逻辑代码中提取出来。降低了代码的耦合度，增加代码的可重用性，减少冗余代码，使得代码更易于维护。</p>
<p>而要为业务模块织入横切动作，就需要使用代理模式来为业务模块创建代理对象，从而将切面应用到目标对象并控制对目标对象的访问。</p>
<p>使用动态代理则减轻了创建代理的工作量，AOP框架将自动生成AOP代理，这样就可以为任何接口实例创建代理对象了。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/wulinbaba" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 wulin<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>